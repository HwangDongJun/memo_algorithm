1. Selection sort
주어진 값 중에 가장 큰 값을 찾고, 맨 끝자리의 data와 자리를 바꾼다.
data를 오름차순으로 정렬하는 것이므로, 맨 끝자리로 옮긴 data는 올바른 자리로 이동했기 때문에 무시해도된다.
이제 정렬할 data가 기본의 크기-1로 같은 방식으로 진행하면 된다.

selectionSort(A[], n) {
    for last <- n downto 2 { //맨 마지막 n에서 2까지(어차피 계속 진행을 하다 1개의 data가 남아도 이미 그건 올바른 위치이기에)
        A[1...last] 중 가장 큰 수 A[k]를 찾는다;
        A[k] <-> A[last]; 값을 서로 교환
    }
}
*실행시간:
 for 루프는 n-1번 반복
 가장 큰수를 찾기 위한 비교횟수: n-1, n-2, ... 2, 1 (주어진 data에서 -1번 만큼 비교를 해야한다. data가 2개 남았을 때, 큰 수는 1번의 비교로 찾을 수 있다.)
 교환은 상수시간 작업
※시간복잡도 T(n) = (n-1) + (n-2) + ... + 2 + 1 = n(n-1)/2 이고, O(n의 제곱)에 해당

2. Bubble sort
첫번째 값을 그 다음 값과 비교해서 크면 자리를 바꾸는 작업을 반복하다가 자신보다 큰 수가 그 다음 값이면 그 값을 그 다음 값과 비교한다.
ex) 29 10 37 13 ~ => 10 29 37 13 ~ => 10 29 13 37 ~ =>... 과 같은 방식
Selection sort와 마찬가지로 맨 마지막까지 이동을 하면 data-1의 크기로 줄여가면서 진행을 한다.

bubbleSort(A[], n) {
    for last <- n downto 2 { //진행을 하는 횟수에 해당
        for i <- 1 to last -1 //마지막은 제외하고 비교해서 교환을 진행 그렇지 않으면 없는 data를 비교
            if (A[i] > A[i+1]) then A[i] <-> A[i+1]; //교환
    }
}
*실행시간: 비교하는 시간만 해당한다.
※시간복잡도 T(n) = (n-1) + (n-2) + ... + 2 + 1 = n(n-1)/2 이고, O(n의 제곱)

3. Insertion sort
처음 2개의 data만을 비교해서 삽입을 한다. 그 다음 data를 가지고 위치를 찾는다.
ex) 15 12 13 ~ 에서 15와 12만을 비교해서 15를 12뒤에 삽입을 한다. 그 후, 13을 가지고 12 15에서 insert할 곳을 찾는다. 12 13 15가 된다.
여기서 insert의 방법이 앞에서 비교와 뒤에서 비교의 2가지의 방법으로 나뉜다.

1) 앞에서 비교를 하면 해당하는 data보다 작은 값들과 넣을 위치를 찾는 순간 뒤의 값들이 뒤로 한칸씩 옮겨져야 하는 과정이 생긴다.
2) 반대로 뒤에서 비교를 하면 해당하는 data보다 크면 자리를 바꿔가면서 진행을 하면 해당하는 data보다 작은 값들은 건드릴 필요가 없어진다.
(뒤에서 비교하는 방법이 좀 더 좋은 방법이다.)

insertionSort(A[], n) {
    for i <- 2 to n { //1의 값은 비교할 것이 없기 때문이다.
        A[1...i]의 적당한 자리에 A[i]를 삽입한다;
   }
}
*시간복잡도:
    for 루프는 n-1번 반복
    삽입은 최악의 경우 i-1번 비교를 계속한다.
※최악의 경우: T(n) = (n-1) + (n-2) + ... + 2 + 1 = O(n의 제곱)에 해당
--> 최악의 경우는 이미 정렬이 되어 있는 값들이 insert해야하는 값보다 크다면 뒤에서 찾는 경우 맨 앞까지 가야한다.
--> 최선의 경우 정렬이 된 값이 자신보다 작다면 n-1번의 비교만 하기에 O(n-1)이다.
★평균적으로는 최선과 최악의 중간정도로 생각하면 된다.