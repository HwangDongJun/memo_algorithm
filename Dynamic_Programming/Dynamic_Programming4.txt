Matrix-Chain Multiplication(행렬의 곱셈)

* p x q 행렬 A와 q x r 행렬 B 곱하기
void product(int A[][], int B[][], int C[][]) {
    for(int i = 0; i < p; i++) {
        for(int j = 0; j < r; j++) {
            C[i][j] = 0;
            for(int k = 0; k < q; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}
p x q 행렬 A와 q x r 행렬 B를 곱하면 p x r 행렬 C가 생성된다.
두개의 행렬의 곱셈은 위와 같은 알고리즘이 대표적이다. -> 연산횟수 : p x q x r이다.

Matrix-Chain 곱하기 -> 여러개의 행렬을 곱한다.
1. p x q 와 r x e 행렬은 곱셈자체가 성립되지 않는다. q와 r위치가 같아야한다.
2. 교환법칙은 성립하지 않으며, 결합법칙의 경우 곱하는 순서에 따라서 연산량이 다름
(행렬 A, B, C에서 A x B인지 B x C인지에 따라 곱셈을 하는 횟수가 다름)

A_1 에서 A_n까지의 행렬곱셈횟수(연산량)을 생각해보자.
=> A_n까지의 최적해중에 중간지점 A_k까지의 곱셈까지의 결과가 X이며, 뒷부분은 Y이고, Z(A_n까지의 곱셈)는 X x Y이다.
=> A_1 ~ A_k까지의 곱셈의 연산량이 가장 적은 최선의 방법이어야 한다.

*순환식을 구하기 위해.
m[i,j] -> 0 (if i = j)
       -> min_i<=k<=j-1(m[i,k] + m[k+1,j] + p_i-1 * p_k * p_j) (if i < j)
p_i-1 * p_k * p_j => 행렬의 곱셈 연산 횟수에 해당한다. (p x q 와 q x r의 연산횟수가 p x q x r 이다.)


//행렬의 대각선으로 계산을 진행한다.(행렬의 곱셈에 관한 횟수 계산)
int matrixChain(int n) {
    for(int i = 1; i <= n; i++)
        m[i][i] = 0; //i가 j보다 작다는 기준으로 대각선에서 왼쪽은 필요가 없으며, 대각선 부분을 0으로 채운다.
    for(int r = 1; r <= n-1; r++) { //첫번째 대각선을 0으로 채웠기 때문에 나머지는 n-1개이다.
        for(int i = 1; i <= n-r; i++) { //대각선 계산은 점점 1씩 줄어들기 때문에 n-r개씩 n-1개 다음 n-2개 다음... n-r까지.
            int j = i + r; //i는 행, i+r은 열을 의미한다.(대각선으로 진행)
            m[i][j] = m[i+1][j] + p[i-1]*p[i]*p[j]; //i와 j가 같은 경우 0이므로 m[i][i] = 0이므로 제외.
            for(int k = i+1; k <= j-1; k++) {
                if(m[i][j] > m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]) //m[i][k]는 가로, m[k+1][j]는 세로
                    m[i][j] = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];
            }
        }
    }
    return m[1][n];
}
//bottom-up방식으로 이전의 값들을 다 구해놔야 하기에 대각선방향으로 구하는 것이다.
*시간복잡도 : O(n의 세제곱)