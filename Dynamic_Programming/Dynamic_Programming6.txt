Knapasck problem

- n개의 아이템과 배낭
- 각각의 아이템은 무게 w_i와 가격 v_i를 가짐
- 배낭의 용량 W
- 목적 : 배낭의 용량을 초과하기 않으면서 가격이 최대가 되는 부분집합

* Greedy한 생각
1. 가격이 높은 것 부터 선택
2. 무게가 가벼운 것부터 선택
3. 단위 무게당 가격이 높은것 부터 선택

* 순환식
OPT(i, w) : 배낭 용량이 w일 때 아이템 1,2,...,i로 얻을 수 있는 최대 이득
경우 1 : 아이템 i를 선택하지 않는 경우
    OPT(i, w) = OPT(i-1, w)
경우 2 : 아이템 i를 선택하는 경우
    OPT(i, w) = OPT(i-1, w-w_i)

OPT(i, w) -> 0 (if i = 0)
          -> OPT(i-1, w) (if w_i > w)
          -> max{OPT(i-1, w), v_i + OPT(i-1, w-w_i)} (otherwise)
경우 2의 경우는 w >= w_i 인 조건이 있어야 한다.

코드를 작성하기 전에 2차원 배열을 만들고 한쪽은 i, 한쪽은 w이다. bottom-up방식으로 만들려고 한다.
순환식을 살펴보면 OPT의 값에 영향을 주는 것은 i-1의 경우밖에 없다. 다른 것들은 왼쪽과 아래쪽이거나 등 구해야 했었다. 여기서는 i-1만 영향을 주는 것이다.
따라서 행 우선순서로 계산을 진행하면 된다.

* 시간복잡도 O(nW) 이다.
* 이 문제는 다항시간인가? -> 아니다.
 => 다항함수란 입력 크기에 대한 다항함수이다. 만약 입력이 n인 문제에서 시간 복잡도가 O(n^2)라면 다항함수이며 다항시간에 해당합니다.

그런데 여긴 n도 입력인데 왜 다항시간이 아닌가? (W는 주어지는 값)
주어지는 값 W는 이진수로 주어지기 때문에 시간복잡도에서는 log_2 W에 대항한다. 그러므로 W는 2^k에 해당하게 된다.
따라서 O(n * 2^k)인 것이다. 다항시간이 아닌 지수시간에 해당한다.
[다음과 같은 설명은 현재로써는 이해하지 않아도 좋다.]